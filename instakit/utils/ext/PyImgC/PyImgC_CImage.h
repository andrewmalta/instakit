#ifndef PyImgC_CIMAGE_H
#define PyImgC_CIMAGE_H

#define cimg_OS 1                       /// unix-like
#define cimg_verbosity 1                /// log to the console
#define cimg_display 0                  /// don't need this

#define cimg_use_png 1                  /// png
#define cimg_use_jpeg 1                 /// jpeg
#define cimg_use_tiff 1                 /// tiff
#define cimg_use_zlib 1                 /// compressed output
#define cimg_use_magick 1               /// ImageMagick++ I/O
#define cimg_use_fftw3 1                /// libFFTW3
//#define cimg_use_openexr 1              /// OpenEXR
//#define cimg_use_lapack 1               /// LAPACK

#include <map>
#include <Python.h>
#include <structmember.h>

#include <numpy/ndarrayobject.h>
#include <numpy/ndarraytypes.h>
#include "numpypp/numpy.hpp"

#include "cimg/CImg.h"
using namespace cimg_library;
using namespace std;
#ifndef cimg_imagepath
#define cimg_imagepath "cimg/img/"
#endif

template <typename T>
struct CCCImage {
    PyObject_HEAD
    PyArray_Descr *dtype;
    CImg<T> *cimage;
};

template <typename T>
CImg<T> from_pybuffer(Py_buffer *pybuffer, int sW, int sH,
                    int channels, bool is_shared=true) {
    CImg<T> view(pybuffer->buf,
        sW, sH, 1,
        channels, is_shared);
    return view;
}

template <typename T>
CImg<T> from_pybuffer(Py_buffer *pybuffer, bool is_shared=true) {
    CImg<T> view(
        pybuffer->buf,
        pybuffer->shape[1],
        pybuffer->shape[0],
        1, 3, is_shared);
    return view;
}

template <typename T>
CImg<T> from_pyarray(PyArrayObject *pyarray, bool is_shared=true) {
    int sW = 0;
    int sH = 0;
    int channels = 0;
    switch (PyArray_NDIM(pyarray)) {
        case 3:
        {
            channels = PyArray_DIM(pyarray, 2); /// starts from zero, right?...
            sW = PyArray_DIM(pyarray, 1);
            sH = PyArray_DIM(pyarray, 0);
        }
        break;
        case 2:
        {
            channels = 1;
            sW = PyArray_DIM(pyarray, 1);
            sH = PyArray_DIM(pyarray, 0);
        }
        break;
        default:
        {
            return NULL;
        }
        break;
    }
    CImg<T> view(PyArray_DATA(pyarray), sW, sH,
        1, channels, is_shared);
    return view;
}

template <typename T>
CImg<T> from_pyobject(PyObject *datasource, int sW, int sH,
                    int channels, bool is_shared=true) {
    CImg<T> view(sW, sH, 1, channels, is_shared);
    return view;
}

template <typename T>
CImg<T> from_pyobject(PyObject *datasource, bool is_shared=true) {
    CImg<T> view(640, 480, 1, 3, is_shared);
    return view;
}

typedef struct CImage_Base {
    CImage_Base() {}
} CImage_Base;

#define REGISTER_TYPESTRUCT(typestruct, typecode)
#define NILCODE '~'

/////////////////////////////////// AUTOGENERATED ///////////////////////////////////////
/////////////////////////////////// AUTOGENERATED ///////////////////////////////////////
/////////////////////////////////// AUTOGENERATED ///////////////////////////////////////


typedef struct CImage_NPY_BOOL : public CImage_Base {
    const char structcode[2] = { '?', NILCODE };
    const unsigned int structcode_length = 2;
    const npy_intp typecode = NPY_BOOL;
    const bool native = true;
    const bool complex = false;

    CImage_NPY_BOOL() {}

    virtual CImg<bool> as_pybuffer(Py_buffer *pybuffer, bool is_shared=true) {
        return from_pybuffer<bool>(pybuffer, is_shared); }

    virtual CImg<bool> as_pybuffer_with_dims(Py_buffer *pybuffer,
        int sW, int sH, int channels=3,
        bool is_shared=true) {
        return from_pybuffer<bool>(pybuffer, sW, sH, channels, is_shared); }

    virtual CImg<bool> as_pyarray(PyArrayObject *pyarray, bool is_shared=true) {
        return from_pyarray<bool>(pyarray, is_shared); }

    virtual CImg<bool> as_datasource(PyObject *datasource, bool is_shared=true) {
        return from_pyobject<bool>(datasource, is_shared); }

    virtual CImg<bool> as_datasource_with_dims(Py_buffer *pybuffer,
        int sW, int sH, int channels=3,
        bool is_shared=true) {
        return from_pybuffer<bool>(pybuffer, sW, sH, channels, is_shared); }

    virtual inline bool operator()(const char sc) {
        for (int idx = 0; structcode[idx] != NILCODE; ++idx) {
            if (structcode[idx] == sc) { return true; }
        }
        return false; }
    virtual inline bool operator[](const npy_intp tc) { return tc == typecode; }

} CImage_NPY_BOOL;

REGISTER_TYPESTRUCT(CImage_NPY_BOOL, NPY_BOOL)


typedef struct CImage_NPY_BYTE : public CImage_Base {
    const char structcode[2] = { 'b', NILCODE };
    const unsigned int structcode_length = 2;
    const npy_intp typecode = NPY_BYTE;
    const bool native = true;
    const bool complex = false;

    CImage_NPY_BYTE() {}

    virtual CImg<char> as_pybuffer(Py_buffer *pybuffer, bool is_shared=true) {
        return from_pybuffer<char>(pybuffer, is_shared); }

    virtual CImg<char> as_pybuffer_with_dims(Py_buffer *pybuffer,
        int sW, int sH, int channels=3,
        bool is_shared=true) {
        return from_pybuffer<char>(pybuffer, sW, sH, channels, is_shared); }

    virtual CImg<char> as_pyarray(PyArrayObject *pyarray, bool is_shared=true) {
        return from_pyarray<char>(pyarray, is_shared); }

    virtual CImg<char> as_datasource(PyObject *datasource, bool is_shared=true) {
        return from_pyobject<char>(datasource, is_shared); }

    virtual CImg<char> as_datasource_with_dims(Py_buffer *pybuffer,
        int sW, int sH, int channels=3,
        bool is_shared=true) {
        return from_pybuffer<char>(pybuffer, sW, sH, channels, is_shared); }

    virtual inline bool operator()(const char sc) {
        for (int idx = 0; structcode[idx] != NILCODE; ++idx) {
            if (structcode[idx] == sc) { return true; }
        }
        return false; }
    virtual inline bool operator[](const npy_intp tc) { return tc == typecode; }

} CImage_NPY_BYTE;

REGISTER_TYPESTRUCT(CImage_NPY_BYTE, NPY_BYTE)


typedef struct CImage_NPY_HALF : public CImage_Base {
    const char structcode[2] = { 'e', NILCODE };
    const unsigned int structcode_length = 2;
    const npy_intp typecode = NPY_HALF;
    const bool native = false;
    const bool complex = false;

    CImage_NPY_HALF() {}

    virtual CImg<npy_half> as_pybuffer(Py_buffer *pybuffer, bool is_shared=true) {
        return from_pybuffer<npy_half>(pybuffer, is_shared); }

    virtual CImg<npy_half> as_pybuffer_with_dims(Py_buffer *pybuffer,
        int sW, int sH, int channels=3,
        bool is_shared=true) {
        return from_pybuffer<npy_half>(pybuffer, sW, sH, channels, is_shared); }

    virtual CImg<npy_half> as_pyarray(PyArrayObject *pyarray, bool is_shared=true) {
        return from_pyarray<npy_half>(pyarray, is_shared); }

    virtual CImg<npy_half> as_datasource(PyObject *datasource, bool is_shared=true) {
        return from_pyobject<npy_half>(datasource, is_shared); }

    virtual CImg<npy_half> as_datasource_with_dims(Py_buffer *pybuffer,
        int sW, int sH, int channels=3,
        bool is_shared=true) {
        return from_pybuffer<npy_half>(pybuffer, sW, sH, channels, is_shared); }

    virtual inline bool operator()(const char sc) {
        for (int idx = 0; structcode[idx] != NILCODE; ++idx) {
            if (structcode[idx] == sc) { return true; }
        }
        return false; }
    virtual inline bool operator[](const npy_intp tc) { return tc == typecode; }

} CImage_NPY_HALF;

REGISTER_TYPESTRUCT(CImage_NPY_HALF, NPY_HALF)


typedef struct CImage_NPY_SHORT : public CImage_Base {
    const char structcode[2] = { 'h', NILCODE };
    const unsigned int structcode_length = 2;
    const npy_intp typecode = NPY_SHORT;
    const bool native = true;
    const bool complex = false;

    CImage_NPY_SHORT() {}

    virtual CImg<short> as_pybuffer(Py_buffer *pybuffer, bool is_shared=true) {
        return from_pybuffer<short>(pybuffer, is_shared); }

    virtual CImg<short> as_pybuffer_with_dims(Py_buffer *pybuffer,
        int sW, int sH, int channels=3,
        bool is_shared=true) {
        return from_pybuffer<short>(pybuffer, sW, sH, channels, is_shared); }

    virtual CImg<short> as_pyarray(PyArrayObject *pyarray, bool is_shared=true) {
        return from_pyarray<short>(pyarray, is_shared); }

    virtual CImg<short> as_datasource(PyObject *datasource, bool is_shared=true) {
        return from_pyobject<short>(datasource, is_shared); }

    virtual CImg<short> as_datasource_with_dims(Py_buffer *pybuffer,
        int sW, int sH, int channels=3,
        bool is_shared=true) {
        return from_pybuffer<short>(pybuffer, sW, sH, channels, is_shared); }

    virtual inline bool operator()(const char sc) {
        for (int idx = 0; structcode[idx] != NILCODE; ++idx) {
            if (structcode[idx] == sc) { return true; }
        }
        return false; }
    virtual inline bool operator[](const npy_intp tc) { return tc == typecode; }

} CImage_NPY_SHORT;

REGISTER_TYPESTRUCT(CImage_NPY_SHORT, NPY_SHORT)


typedef struct CImage_NPY_INT : public CImage_Base {
    const char structcode[2] = { 'i', NILCODE };
    const unsigned int structcode_length = 2;
    const npy_intp typecode = NPY_INT;
    const bool native = true;
    const bool complex = false;

    CImage_NPY_INT() {}

    virtual CImg<int> as_pybuffer(Py_buffer *pybuffer, bool is_shared=true) {
        return from_pybuffer<int>(pybuffer, is_shared); }

    virtual CImg<int> as_pybuffer_with_dims(Py_buffer *pybuffer,
        int sW, int sH, int channels=3,
        bool is_shared=true) {
        return from_pybuffer<int>(pybuffer, sW, sH, channels, is_shared); }

    virtual CImg<int> as_pyarray(PyArrayObject *pyarray, bool is_shared=true) {
        return from_pyarray<int>(pyarray, is_shared); }

    virtual CImg<int> as_datasource(PyObject *datasource, bool is_shared=true) {
        return from_pyobject<int>(datasource, is_shared); }

    virtual CImg<int> as_datasource_with_dims(Py_buffer *pybuffer,
        int sW, int sH, int channels=3,
        bool is_shared=true) {
        return from_pybuffer<int>(pybuffer, sW, sH, channels, is_shared); }

    virtual inline bool operator()(const char sc) {
        for (int idx = 0; structcode[idx] != NILCODE; ++idx) {
            if (structcode[idx] == sc) { return true; }
        }
        return false; }
    virtual inline bool operator[](const npy_intp tc) { return tc == typecode; }

} CImage_NPY_INT;

REGISTER_TYPESTRUCT(CImage_NPY_INT, NPY_INT)


typedef struct CImage_NPY_LONG : public CImage_Base {
    const char structcode[2] = { 'l', NILCODE };
    const unsigned int structcode_length = 2;
    const npy_intp typecode = NPY_LONG;
    const bool native = true;
    const bool complex = false;

    CImage_NPY_LONG() {}

    virtual CImg<long> as_pybuffer(Py_buffer *pybuffer, bool is_shared=true) {
        return from_pybuffer<long>(pybuffer, is_shared); }

    virtual CImg<long> as_pybuffer_with_dims(Py_buffer *pybuffer,
        int sW, int sH, int channels=3,
        bool is_shared=true) {
        return from_pybuffer<long>(pybuffer, sW, sH, channels, is_shared); }

    virtual CImg<long> as_pyarray(PyArrayObject *pyarray, bool is_shared=true) {
        return from_pyarray<long>(pyarray, is_shared); }

    virtual CImg<long> as_datasource(PyObject *datasource, bool is_shared=true) {
        return from_pyobject<long>(datasource, is_shared); }

    virtual CImg<long> as_datasource_with_dims(Py_buffer *pybuffer,
        int sW, int sH, int channels=3,
        bool is_shared=true) {
        return from_pybuffer<long>(pybuffer, sW, sH, channels, is_shared); }

    virtual inline bool operator()(const char sc) {
        for (int idx = 0; structcode[idx] != NILCODE; ++idx) {
            if (structcode[idx] == sc) { return true; }
        }
        return false; }
    virtual inline bool operator[](const npy_intp tc) { return tc == typecode; }

} CImage_NPY_LONG;

REGISTER_TYPESTRUCT(CImage_NPY_LONG, NPY_LONG)


typedef struct CImage_NPY_LONGLONG : public CImage_Base {
    const char structcode[2] = { 'q', NILCODE };
    const unsigned int structcode_length = 2;
    const npy_intp typecode = NPY_LONGLONG;
    const bool native = true;
    const bool complex = false;

    CImage_NPY_LONGLONG() {}

    virtual CImg<long long> as_pybuffer(Py_buffer *pybuffer, bool is_shared=true) {
        return from_pybuffer<long long>(pybuffer, is_shared); }

    virtual CImg<long long> as_pybuffer_with_dims(Py_buffer *pybuffer,
        int sW, int sH, int channels=3,
        bool is_shared=true) {
        return from_pybuffer<long long>(pybuffer, sW, sH, channels, is_shared); }

    virtual CImg<long long> as_pyarray(PyArrayObject *pyarray, bool is_shared=true) {
        return from_pyarray<long long>(pyarray, is_shared); }

    virtual CImg<long long> as_datasource(PyObject *datasource, bool is_shared=true) {
        return from_pyobject<long long>(datasource, is_shared); }

    virtual CImg<long long> as_datasource_with_dims(Py_buffer *pybuffer,
        int sW, int sH, int channels=3,
        bool is_shared=true) {
        return from_pybuffer<long long>(pybuffer, sW, sH, channels, is_shared); }

    virtual inline bool operator()(const char sc) {
        for (int idx = 0; structcode[idx] != NILCODE; ++idx) {
            if (structcode[idx] == sc) { return true; }
        }
        return false; }
    virtual inline bool operator[](const npy_intp tc) { return tc == typecode; }

} CImage_NPY_LONGLONG;

REGISTER_TYPESTRUCT(CImage_NPY_LONGLONG, NPY_LONGLONG)


typedef struct CImage_NPY_UBYTE : public CImage_Base {
    const char structcode[2] = { 'B', NILCODE };
    const unsigned int structcode_length = 2;
    const npy_intp typecode = NPY_UBYTE;
    const bool native = true;
    const bool complex = false;

    CImage_NPY_UBYTE() {}

    virtual CImg<unsigned char> as_pybuffer(Py_buffer *pybuffer, bool is_shared=true) {
        return from_pybuffer<unsigned char>(pybuffer, is_shared); }

    virtual CImg<unsigned char> as_pybuffer_with_dims(Py_buffer *pybuffer,
        int sW, int sH, int channels=3,
        bool is_shared=true) {
        return from_pybuffer<unsigned char>(pybuffer, sW, sH, channels, is_shared); }

    virtual CImg<unsigned char> as_pyarray(PyArrayObject *pyarray, bool is_shared=true) {
        return from_pyarray<unsigned char>(pyarray, is_shared); }

    virtual CImg<unsigned char> as_datasource(PyObject *datasource, bool is_shared=true) {
        return from_pyobject<unsigned char>(datasource, is_shared); }

    virtual CImg<unsigned char> as_datasource_with_dims(Py_buffer *pybuffer,
        int sW, int sH, int channels=3,
        bool is_shared=true) {
        return from_pybuffer<unsigned char>(pybuffer, sW, sH, channels, is_shared); }

    virtual inline bool operator()(const char sc) {
        for (int idx = 0; structcode[idx] != NILCODE; ++idx) {
            if (structcode[idx] == sc) { return true; }
        }
        return false; }
    virtual inline bool operator[](const npy_intp tc) { return tc == typecode; }

} CImage_NPY_UBYTE;

REGISTER_TYPESTRUCT(CImage_NPY_UBYTE, NPY_UBYTE)


typedef struct CImage_NPY_USHORT : public CImage_Base {
    const char structcode[2] = { 'H', NILCODE };
    const unsigned int structcode_length = 2;
    const npy_intp typecode = NPY_USHORT;
    const bool native = true;
    const bool complex = false;

    CImage_NPY_USHORT() {}

    virtual CImg<unsigned short> as_pybuffer(Py_buffer *pybuffer, bool is_shared=true) {
        return from_pybuffer<unsigned short>(pybuffer, is_shared); }

    virtual CImg<unsigned short> as_pybuffer_with_dims(Py_buffer *pybuffer,
        int sW, int sH, int channels=3,
        bool is_shared=true) {
        return from_pybuffer<unsigned short>(pybuffer, sW, sH, channels, is_shared); }

    virtual CImg<unsigned short> as_pyarray(PyArrayObject *pyarray, bool is_shared=true) {
        return from_pyarray<unsigned short>(pyarray, is_shared); }

    virtual CImg<unsigned short> as_datasource(PyObject *datasource, bool is_shared=true) {
        return from_pyobject<unsigned short>(datasource, is_shared); }

    virtual CImg<unsigned short> as_datasource_with_dims(Py_buffer *pybuffer,
        int sW, int sH, int channels=3,
        bool is_shared=true) {
        return from_pybuffer<unsigned short>(pybuffer, sW, sH, channels, is_shared); }

    virtual inline bool operator()(const char sc) {
        for (int idx = 0; structcode[idx] != NILCODE; ++idx) {
            if (structcode[idx] == sc) { return true; }
        }
        return false; }
    virtual inline bool operator[](const npy_intp tc) { return tc == typecode; }

} CImage_NPY_USHORT;

REGISTER_TYPESTRUCT(CImage_NPY_USHORT, NPY_USHORT)


typedef struct CImage_NPY_UINT : public CImage_Base {
    const char structcode[2] = { 'I', NILCODE };
    const unsigned int structcode_length = 2;
    const npy_intp typecode = NPY_UINT;
    const bool native = true;
    const bool complex = false;

    CImage_NPY_UINT() {}

    virtual CImg<unsigned int> as_pybuffer(Py_buffer *pybuffer, bool is_shared=true) {
        return from_pybuffer<unsigned int>(pybuffer, is_shared); }

    virtual CImg<unsigned int> as_pybuffer_with_dims(Py_buffer *pybuffer,
        int sW, int sH, int channels=3,
        bool is_shared=true) {
        return from_pybuffer<unsigned int>(pybuffer, sW, sH, channels, is_shared); }

    virtual CImg<unsigned int> as_pyarray(PyArrayObject *pyarray, bool is_shared=true) {
        return from_pyarray<unsigned int>(pyarray, is_shared); }

    virtual CImg<unsigned int> as_datasource(PyObject *datasource, bool is_shared=true) {
        return from_pyobject<unsigned int>(datasource, is_shared); }

    virtual CImg<unsigned int> as_datasource_with_dims(Py_buffer *pybuffer,
        int sW, int sH, int channels=3,
        bool is_shared=true) {
        return from_pybuffer<unsigned int>(pybuffer, sW, sH, channels, is_shared); }

    virtual inline bool operator()(const char sc) {
        for (int idx = 0; structcode[idx] != NILCODE; ++idx) {
            if (structcode[idx] == sc) { return true; }
        }
        return false; }
    virtual inline bool operator[](const npy_intp tc) { return tc == typecode; }

} CImage_NPY_UINT;

REGISTER_TYPESTRUCT(CImage_NPY_UINT, NPY_UINT)


typedef struct CImage_NPY_ULONG : public CImage_Base {
    const char structcode[2] = { 'L', NILCODE };
    const unsigned int structcode_length = 2;
    const npy_intp typecode = NPY_ULONG;
    const bool native = true;
    const bool complex = false;

    CImage_NPY_ULONG() {}

    virtual CImg<unsigned long> as_pybuffer(Py_buffer *pybuffer, bool is_shared=true) {
        return from_pybuffer<unsigned long>(pybuffer, is_shared); }

    virtual CImg<unsigned long> as_pybuffer_with_dims(Py_buffer *pybuffer,
        int sW, int sH, int channels=3,
        bool is_shared=true) {
        return from_pybuffer<unsigned long>(pybuffer, sW, sH, channels, is_shared); }

    virtual CImg<unsigned long> as_pyarray(PyArrayObject *pyarray, bool is_shared=true) {
        return from_pyarray<unsigned long>(pyarray, is_shared); }

    virtual CImg<unsigned long> as_datasource(PyObject *datasource, bool is_shared=true) {
        return from_pyobject<unsigned long>(datasource, is_shared); }

    virtual CImg<unsigned long> as_datasource_with_dims(Py_buffer *pybuffer,
        int sW, int sH, int channels=3,
        bool is_shared=true) {
        return from_pybuffer<unsigned long>(pybuffer, sW, sH, channels, is_shared); }

    virtual inline bool operator()(const char sc) {
        for (int idx = 0; structcode[idx] != NILCODE; ++idx) {
            if (structcode[idx] == sc) { return true; }
        }
        return false; }
    virtual inline bool operator[](const npy_intp tc) { return tc == typecode; }

} CImage_NPY_ULONG;

REGISTER_TYPESTRUCT(CImage_NPY_ULONG, NPY_ULONG)


typedef struct CImage_NPY_ULONGLONG : public CImage_Base {
    const char structcode[2] = { 'Q', NILCODE };
    const unsigned int structcode_length = 2;
    const npy_intp typecode = NPY_ULONGLONG;
    const bool native = true;
    const bool complex = false;

    CImage_NPY_ULONGLONG() {}

    virtual CImg<unsigned long long> as_pybuffer(Py_buffer *pybuffer, bool is_shared=true) {
        return from_pybuffer<unsigned long long>(pybuffer, is_shared); }

    virtual CImg<unsigned long long> as_pybuffer_with_dims(Py_buffer *pybuffer,
        int sW, int sH, int channels=3,
        bool is_shared=true) {
        return from_pybuffer<unsigned long long>(pybuffer, sW, sH, channels, is_shared); }

    virtual CImg<unsigned long long> as_pyarray(PyArrayObject *pyarray, bool is_shared=true) {
        return from_pyarray<unsigned long long>(pyarray, is_shared); }

    virtual CImg<unsigned long long> as_datasource(PyObject *datasource, bool is_shared=true) {
        return from_pyobject<unsigned long long>(datasource, is_shared); }

    virtual CImg<unsigned long long> as_datasource_with_dims(Py_buffer *pybuffer,
        int sW, int sH, int channels=3,
        bool is_shared=true) {
        return from_pybuffer<unsigned long long>(pybuffer, sW, sH, channels, is_shared); }

    virtual inline bool operator()(const char sc) {
        for (int idx = 0; structcode[idx] != NILCODE; ++idx) {
            if (structcode[idx] == sc) { return true; }
        }
        return false; }
    virtual inline bool operator[](const npy_intp tc) { return tc == typecode; }

} CImage_NPY_ULONGLONG;

REGISTER_TYPESTRUCT(CImage_NPY_ULONGLONG, NPY_ULONGLONG)


typedef struct CImage_NPY_INT16 : public CImage_Base {
    const char structcode[2] = { 'h', NILCODE };
    const unsigned int structcode_length = 2;
    const npy_intp typecode = NPY_INT16;
    const bool native = false;
    const bool complex = false;

    CImage_NPY_INT16() {}

    virtual CImg<short> as_pybuffer(Py_buffer *pybuffer, bool is_shared=true) {
        return from_pybuffer<short>(pybuffer, is_shared); }

    virtual CImg<short> as_pybuffer_with_dims(Py_buffer *pybuffer,
        int sW, int sH, int channels=3,
        bool is_shared=true) {
        return from_pybuffer<short>(pybuffer, sW, sH, channels, is_shared); }

    virtual CImg<short> as_pyarray(PyArrayObject *pyarray, bool is_shared=true) {
        return from_pyarray<short>(pyarray, is_shared); }

    virtual CImg<short> as_datasource(PyObject *datasource, bool is_shared=true) {
        return from_pyobject<short>(datasource, is_shared); }

    virtual CImg<short> as_datasource_with_dims(Py_buffer *pybuffer,
        int sW, int sH, int channels=3,
        bool is_shared=true) {
        return from_pybuffer<short>(pybuffer, sW, sH, channels, is_shared); }

    virtual inline bool operator()(const char sc) {
        for (int idx = 0; structcode[idx] != NILCODE; ++idx) {
            if (structcode[idx] == sc) { return true; }
        }
        return false; }
    virtual inline bool operator[](const npy_intp tc) { return tc == typecode; }

} CImage_NPY_INT16;

REGISTER_TYPESTRUCT(CImage_NPY_INT16, NPY_INT16)


typedef struct CImage_NPY_INT32 : public CImage_Base {
    const char structcode[3] = { 'i', 'l', NILCODE };
    const unsigned int structcode_length = 3;
    const npy_intp typecode = NPY_INT32;
    const bool native = false;
    const bool complex = false;

    CImage_NPY_INT32() {}

    virtual CImg<int> as_pybuffer(Py_buffer *pybuffer, bool is_shared=true) {
        return from_pybuffer<int>(pybuffer, is_shared); }

    virtual CImg<int> as_pybuffer_with_dims(Py_buffer *pybuffer,
        int sW, int sH, int channels=3,
        bool is_shared=true) {
        return from_pybuffer<int>(pybuffer, sW, sH, channels, is_shared); }

    virtual CImg<int> as_pyarray(PyArrayObject *pyarray, bool is_shared=true) {
        return from_pyarray<int>(pyarray, is_shared); }

    virtual CImg<int> as_datasource(PyObject *datasource, bool is_shared=true) {
        return from_pyobject<int>(datasource, is_shared); }

    virtual CImg<int> as_datasource_with_dims(Py_buffer *pybuffer,
        int sW, int sH, int channels=3,
        bool is_shared=true) {
        return from_pybuffer<int>(pybuffer, sW, sH, channels, is_shared); }

    virtual inline bool operator()(const char sc) {
        for (int idx = 0; structcode[idx] != NILCODE; ++idx) {
            if (structcode[idx] == sc) { return true; }
        }
        return false; }
    virtual inline bool operator[](const npy_intp tc) { return tc == typecode; }

} CImage_NPY_INT32;

REGISTER_TYPESTRUCT(CImage_NPY_INT32, NPY_INT32)


typedef struct CImage_NPY_INT64 : public CImage_Base {
    const char structcode[2] = { 'q', NILCODE };
    const unsigned int structcode_length = 2;
    const npy_intp typecode = NPY_INT64;
    const bool native = false;
    const bool complex = false;

    CImage_NPY_INT64() {}

    virtual CImg<long long> as_pybuffer(Py_buffer *pybuffer, bool is_shared=true) {
        return from_pybuffer<long long>(pybuffer, is_shared); }

    virtual CImg<long long> as_pybuffer_with_dims(Py_buffer *pybuffer,
        int sW, int sH, int channels=3,
        bool is_shared=true) {
        return from_pybuffer<long long>(pybuffer, sW, sH, channels, is_shared); }

    virtual CImg<long long> as_pyarray(PyArrayObject *pyarray, bool is_shared=true) {
        return from_pyarray<long long>(pyarray, is_shared); }

    virtual CImg<long long> as_datasource(PyObject *datasource, bool is_shared=true) {
        return from_pyobject<long long>(datasource, is_shared); }

    virtual CImg<long long> as_datasource_with_dims(Py_buffer *pybuffer,
        int sW, int sH, int channels=3,
        bool is_shared=true) {
        return from_pybuffer<long long>(pybuffer, sW, sH, channels, is_shared); }

    virtual inline bool operator()(const char sc) {
        for (int idx = 0; structcode[idx] != NILCODE; ++idx) {
            if (structcode[idx] == sc) { return true; }
        }
        return false; }
    virtual inline bool operator[](const npy_intp tc) { return tc == typecode; }

} CImage_NPY_INT64;

REGISTER_TYPESTRUCT(CImage_NPY_INT64, NPY_INT64)


typedef struct CImage_NPY_UINT16 : public CImage_Base {
    const char structcode[2] = { 'H', NILCODE };
    const unsigned int structcode_length = 2;
    const npy_intp typecode = NPY_UINT16;
    const bool native = false;
    const bool complex = false;

    CImage_NPY_UINT16() {}

    virtual CImg<unsigned short> as_pybuffer(Py_buffer *pybuffer, bool is_shared=true) {
        return from_pybuffer<unsigned short>(pybuffer, is_shared); }

    virtual CImg<unsigned short> as_pybuffer_with_dims(Py_buffer *pybuffer,
        int sW, int sH, int channels=3,
        bool is_shared=true) {
        return from_pybuffer<unsigned short>(pybuffer, sW, sH, channels, is_shared); }

    virtual CImg<unsigned short> as_pyarray(PyArrayObject *pyarray, bool is_shared=true) {
        return from_pyarray<unsigned short>(pyarray, is_shared); }

    virtual CImg<unsigned short> as_datasource(PyObject *datasource, bool is_shared=true) {
        return from_pyobject<unsigned short>(datasource, is_shared); }

    virtual CImg<unsigned short> as_datasource_with_dims(Py_buffer *pybuffer,
        int sW, int sH, int channels=3,
        bool is_shared=true) {
        return from_pybuffer<unsigned short>(pybuffer, sW, sH, channels, is_shared); }

    virtual inline bool operator()(const char sc) {
        for (int idx = 0; structcode[idx] != NILCODE; ++idx) {
            if (structcode[idx] == sc) { return true; }
        }
        return false; }
    virtual inline bool operator[](const npy_intp tc) { return tc == typecode; }

} CImage_NPY_UINT16;

REGISTER_TYPESTRUCT(CImage_NPY_UINT16, NPY_UINT16)


typedef struct CImage_NPY_UINT32 : public CImage_Base {
    const char structcode[3] = { 'I', 'L', NILCODE };
    const unsigned int structcode_length = 3;
    const npy_intp typecode = NPY_UINT32;
    const bool native = false;
    const bool complex = false;

    CImage_NPY_UINT32() {}

    virtual CImg<unsigned int> as_pybuffer(Py_buffer *pybuffer, bool is_shared=true) {
        return from_pybuffer<unsigned int>(pybuffer, is_shared); }

    virtual CImg<unsigned int> as_pybuffer_with_dims(Py_buffer *pybuffer,
        int sW, int sH, int channels=3,
        bool is_shared=true) {
        return from_pybuffer<unsigned int>(pybuffer, sW, sH, channels, is_shared); }

    virtual CImg<unsigned int> as_pyarray(PyArrayObject *pyarray, bool is_shared=true) {
        return from_pyarray<unsigned int>(pyarray, is_shared); }

    virtual CImg<unsigned int> as_datasource(PyObject *datasource, bool is_shared=true) {
        return from_pyobject<unsigned int>(datasource, is_shared); }

    virtual CImg<unsigned int> as_datasource_with_dims(Py_buffer *pybuffer,
        int sW, int sH, int channels=3,
        bool is_shared=true) {
        return from_pybuffer<unsigned int>(pybuffer, sW, sH, channels, is_shared); }

    virtual inline bool operator()(const char sc) {
        for (int idx = 0; structcode[idx] != NILCODE; ++idx) {
            if (structcode[idx] == sc) { return true; }
        }
        return false; }
    virtual inline bool operator[](const npy_intp tc) { return tc == typecode; }

} CImage_NPY_UINT32;

REGISTER_TYPESTRUCT(CImage_NPY_UINT32, NPY_UINT32)


typedef struct CImage_NPY_UINT64 : public CImage_Base {
    const char structcode[2] = { 'Q', NILCODE };
    const unsigned int structcode_length = 2;
    const npy_intp typecode = NPY_UINT64;
    const bool native = false;
    const bool complex = false;

    CImage_NPY_UINT64() {}

    virtual CImg<unsigned long long> as_pybuffer(Py_buffer *pybuffer, bool is_shared=true) {
        return from_pybuffer<unsigned long long>(pybuffer, is_shared); }

    virtual CImg<unsigned long long> as_pybuffer_with_dims(Py_buffer *pybuffer,
        int sW, int sH, int channels=3,
        bool is_shared=true) {
        return from_pybuffer<unsigned long long>(pybuffer, sW, sH, channels, is_shared); }

    virtual CImg<unsigned long long> as_pyarray(PyArrayObject *pyarray, bool is_shared=true) {
        return from_pyarray<unsigned long long>(pyarray, is_shared); }

    virtual CImg<unsigned long long> as_datasource(PyObject *datasource, bool is_shared=true) {
        return from_pyobject<unsigned long long>(datasource, is_shared); }

    virtual CImg<unsigned long long> as_datasource_with_dims(Py_buffer *pybuffer,
        int sW, int sH, int channels=3,
        bool is_shared=true) {
        return from_pybuffer<unsigned long long>(pybuffer, sW, sH, channels, is_shared); }

    virtual inline bool operator()(const char sc) {
        for (int idx = 0; structcode[idx] != NILCODE; ++idx) {
            if (structcode[idx] == sc) { return true; }
        }
        return false; }
    virtual inline bool operator[](const npy_intp tc) { return tc == typecode; }

} CImage_NPY_UINT64;

REGISTER_TYPESTRUCT(CImage_NPY_UINT64, NPY_UINT64)


typedef struct CImage_NPY_CFLOAT : public CImage_Base {
    const char structcode[2] = { 'f', NILCODE };
    const unsigned int structcode_length = 2;
    const npy_intp typecode = NPY_CFLOAT;
    const bool native = false;
    const bool complex = true;

    CImage_NPY_CFLOAT() {}

    virtual CImg<std::complex<float>> as_pybuffer(Py_buffer *pybuffer, bool is_shared=true) {
        return from_pybuffer<std::complex<float>>(pybuffer, is_shared); }

    virtual CImg<std::complex<float>> as_pybuffer_with_dims(Py_buffer *pybuffer,
        int sW, int sH, int channels=3,
        bool is_shared=true) {
        return from_pybuffer<std::complex<float>>(pybuffer, sW, sH, channels, is_shared); }

    virtual CImg<std::complex<float>> as_pyarray(PyArrayObject *pyarray, bool is_shared=true) {
        return from_pyarray<std::complex<float>>(pyarray, is_shared); }

    virtual CImg<std::complex<float>> as_datasource(PyObject *datasource, bool is_shared=true) {
        return from_pyobject<std::complex<float>>(datasource, is_shared); }

    virtual CImg<std::complex<float>> as_datasource_with_dims(Py_buffer *pybuffer,
        int sW, int sH, int channels=3,
        bool is_shared=true) {
        return from_pybuffer<std::complex<float>>(pybuffer, sW, sH, channels, is_shared); }

    virtual inline bool operator()(const char sc) {
        for (int idx = 0; structcode[idx] != NILCODE; ++idx) {
            if (structcode[idx] == sc) { return true; }
        }
        return false; }
    virtual inline bool operator[](const npy_intp tc) { return tc == typecode; }

} CImage_NPY_CFLOAT;

REGISTER_TYPESTRUCT(CImage_NPY_CFLOAT, NPY_CFLOAT)


typedef struct CImage_NPY_CDOUBLE : public CImage_Base {
    const char structcode[2] = { 'd', NILCODE };
    const unsigned int structcode_length = 2;
    const npy_intp typecode = NPY_CDOUBLE;
    const bool native = false;
    const bool complex = true;

    CImage_NPY_CDOUBLE() {}

    virtual CImg<std::complex<double>> as_pybuffer(Py_buffer *pybuffer, bool is_shared=true) {
        return from_pybuffer<std::complex<double>>(pybuffer, is_shared); }

    virtual CImg<std::complex<double>> as_pybuffer_with_dims(Py_buffer *pybuffer,
        int sW, int sH, int channels=3,
        bool is_shared=true) {
        return from_pybuffer<std::complex<double>>(pybuffer, sW, sH, channels, is_shared); }

    virtual CImg<std::complex<double>> as_pyarray(PyArrayObject *pyarray, bool is_shared=true) {
        return from_pyarray<std::complex<double>>(pyarray, is_shared); }

    virtual CImg<std::complex<double>> as_datasource(PyObject *datasource, bool is_shared=true) {
        return from_pyobject<std::complex<double>>(datasource, is_shared); }

    virtual CImg<std::complex<double>> as_datasource_with_dims(Py_buffer *pybuffer,
        int sW, int sH, int channels=3,
        bool is_shared=true) {
        return from_pybuffer<std::complex<double>>(pybuffer, sW, sH, channels, is_shared); }

    virtual inline bool operator()(const char sc) {
        for (int idx = 0; structcode[idx] != NILCODE; ++idx) {
            if (structcode[idx] == sc) { return true; }
        }
        return false; }
    virtual inline bool operator[](const npy_intp tc) { return tc == typecode; }

} CImage_NPY_CDOUBLE;

REGISTER_TYPESTRUCT(CImage_NPY_CDOUBLE, NPY_CDOUBLE)


typedef struct CImage_NPY_FLOAT : public CImage_Base {
    const char structcode[2] = { 'f', NILCODE };
    const unsigned int structcode_length = 2;
    const npy_intp typecode = NPY_FLOAT;
    const bool native = false;
    const bool complex = false;

    CImage_NPY_FLOAT() {}

    virtual CImg<float> as_pybuffer(Py_buffer *pybuffer, bool is_shared=true) {
        return from_pybuffer<float>(pybuffer, is_shared); }

    virtual CImg<float> as_pybuffer_with_dims(Py_buffer *pybuffer,
        int sW, int sH, int channels=3,
        bool is_shared=true) {
        return from_pybuffer<float>(pybuffer, sW, sH, channels, is_shared); }

    virtual CImg<float> as_pyarray(PyArrayObject *pyarray, bool is_shared=true) {
        return from_pyarray<float>(pyarray, is_shared); }

    virtual CImg<float> as_datasource(PyObject *datasource, bool is_shared=true) {
        return from_pyobject<float>(datasource, is_shared); }

    virtual CImg<float> as_datasource_with_dims(Py_buffer *pybuffer,
        int sW, int sH, int channels=3,
        bool is_shared=true) {
        return from_pybuffer<float>(pybuffer, sW, sH, channels, is_shared); }

    virtual inline bool operator()(const char sc) {
        for (int idx = 0; structcode[idx] != NILCODE; ++idx) {
            if (structcode[idx] == sc) { return true; }
        }
        return false; }
    virtual inline bool operator[](const npy_intp tc) { return tc == typecode; }

} CImage_NPY_FLOAT;

REGISTER_TYPESTRUCT(CImage_NPY_FLOAT, NPY_FLOAT)


typedef struct CImage_NPY_DOUBLE : public CImage_Base {
    const char structcode[2] = { 'd', NILCODE };
    const unsigned int structcode_length = 2;
    const npy_intp typecode = NPY_DOUBLE;
    const bool native = false;
    const bool complex = false;

    CImage_NPY_DOUBLE() {}

    virtual CImg<double> as_pybuffer(Py_buffer *pybuffer, bool is_shared=true) {
        return from_pybuffer<double>(pybuffer, is_shared); }

    virtual CImg<double> as_pybuffer_with_dims(Py_buffer *pybuffer,
        int sW, int sH, int channels=3,
        bool is_shared=true) {
        return from_pybuffer<double>(pybuffer, sW, sH, channels, is_shared); }

    virtual CImg<double> as_pyarray(PyArrayObject *pyarray, bool is_shared=true) {
        return from_pyarray<double>(pyarray, is_shared); }

    virtual CImg<double> as_datasource(PyObject *datasource, bool is_shared=true) {
        return from_pyobject<double>(datasource, is_shared); }

    virtual CImg<double> as_datasource_with_dims(Py_buffer *pybuffer,
        int sW, int sH, int channels=3,
        bool is_shared=true) {
        return from_pybuffer<double>(pybuffer, sW, sH, channels, is_shared); }

    virtual inline bool operator()(const char sc) {
        for (int idx = 0; structcode[idx] != NILCODE; ++idx) {
            if (structcode[idx] == sc) { return true; }
        }
        return false; }
    virtual inline bool operator[](const npy_intp tc) { return tc == typecode; }

} CImage_NPY_DOUBLE;

REGISTER_TYPESTRUCT(CImage_NPY_DOUBLE, NPY_DOUBLE)


typedef struct CImage_NPY_CLONGDOUBLE : public CImage_Base {
    const char structcode[2] = { 'g', NILCODE };
    const unsigned int structcode_length = 2;
    const npy_intp typecode = NPY_CLONGDOUBLE;
    const bool native = true;
    const bool complex = false;

    CImage_NPY_CLONGDOUBLE() {}

    virtual CImg<std::complex<long double>> as_pybuffer(Py_buffer *pybuffer, bool is_shared=true) {
        return from_pybuffer<std::complex<long double>>(pybuffer, is_shared); }

    virtual CImg<std::complex<long double>> as_pybuffer_with_dims(Py_buffer *pybuffer,
        int sW, int sH, int channels=3,
        bool is_shared=true) {
        return from_pybuffer<std::complex<long double>>(pybuffer, sW, sH, channels, is_shared); }

    virtual CImg<std::complex<long double>> as_pyarray(PyArrayObject *pyarray, bool is_shared=true) {
        return from_pyarray<std::complex<long double>>(pyarray, is_shared); }

    virtual CImg<std::complex<long double>> as_datasource(PyObject *datasource, bool is_shared=true) {
        return from_pyobject<std::complex<long double>>(datasource, is_shared); }

    virtual CImg<std::complex<long double>> as_datasource_with_dims(Py_buffer *pybuffer,
        int sW, int sH, int channels=3,
        bool is_shared=true) {
        return from_pybuffer<std::complex<long double>>(pybuffer, sW, sH, channels, is_shared); }

    virtual inline bool operator()(const char sc) {
        for (int idx = 0; structcode[idx] != NILCODE; ++idx) {
            if (structcode[idx] == sc) { return true; }
        }
        return false; }
    virtual inline bool operator[](const npy_intp tc) { return tc == typecode; }

} CImage_NPY_CLONGDOUBLE;

REGISTER_TYPESTRUCT(CImage_NPY_CLONGDOUBLE, NPY_CLONGDOUBLE)


typedef struct CImage_NPY_LONGDOUBLE : public CImage_Base {
    const char structcode[2] = { 'g', NILCODE };
    const unsigned int structcode_length = 2;
    const npy_intp typecode = NPY_LONGDOUBLE;
    const bool native = true;
    const bool complex = true;

    CImage_NPY_LONGDOUBLE() {}

    virtual CImg<std::complex<long double>> as_pybuffer(Py_buffer *pybuffer, bool is_shared=true) {
        return from_pybuffer<std::complex<long double>>(pybuffer, is_shared); }

    virtual CImg<std::complex<long double>> as_pybuffer_with_dims(Py_buffer *pybuffer,
        int sW, int sH, int channels=3,
        bool is_shared=true) {
        return from_pybuffer<std::complex<long double>>(pybuffer, sW, sH, channels, is_shared); }

    virtual CImg<std::complex<long double>> as_pyarray(PyArrayObject *pyarray, bool is_shared=true) {
        return from_pyarray<std::complex<long double>>(pyarray, is_shared); }

    virtual CImg<std::complex<long double>> as_datasource(PyObject *datasource, bool is_shared=true) {
        return from_pyobject<std::complex<long double>>(datasource, is_shared); }

    virtual CImg<std::complex<long double>> as_datasource_with_dims(Py_buffer *pybuffer,
        int sW, int sH, int channels=3,
        bool is_shared=true) {
        return from_pybuffer<std::complex<long double>>(pybuffer, sW, sH, channels, is_shared); }

    virtual inline bool operator()(const char sc) {
        for (int idx = 0; structcode[idx] != NILCODE; ++idx) {
            if (structcode[idx] == sc) { return true; }
        }
        return false; }
    virtual inline bool operator[](const npy_intp tc) { return tc == typecode; }

} CImage_NPY_LONGDOUBLE;

REGISTER_TYPESTRUCT(CImage_NPY_LONGDOUBLE, NPY_LONGDOUBLE)

/////////////////////////////////// !AUTOGENERATED ///////////////////////////////////////
/////////////////////////////////// !AUTOGENERATED ///////////////////////////////////////
/////////////////////////////////// !AUTOGENERATED ///////////////////////////////////////


struct typecodemap {
    
    static map<npy_intp, CImage_Base> init_cimage_wrappers() {
        map<npy_intp, CImage_Base> _cimage_wrapper_map = {
            { NPY_BOOL, CImage_NPY_BOOL() },
            { NPY_BYTE, CImage_NPY_BYTE() },
            { NPY_UBYTE, CImage_NPY_UBYTE() },

            { NPY_INT16, CImage_NPY_INT16() },
            { NPY_UINT16, CImage_NPY_UINT16() },
            { NPY_INT32, CImage_NPY_INT32() },
            { NPY_UINT32, CImage_NPY_UINT32() },
            { NPY_INT32, CImage_NPY_INT32() },
            { NPY_UINT32, CImage_NPY_UINT32() },
            { NPY_INT64, CImage_NPY_INT64() },
            { NPY_UINT64, CImage_NPY_UINT64() },

            { NPY_HALF, CImage_NPY_HALF() },
            { NPY_FLOAT, CImage_NPY_FLOAT() },
            { NPY_DOUBLE, CImage_NPY_DOUBLE() },
            { NPY_LONGDOUBLE, CImage_NPY_LONGDOUBLE() },
            { NPY_CFLOAT, CImage_NPY_CFLOAT() },
            { NPY_CDOUBLE, CImage_NPY_CDOUBLE() },
            { NPY_CLONGDOUBLE, CImage_NPY_CLONGDOUBLE() },

            { NPY_SHORT, CImage_NPY_SHORT() },
            { NPY_USHORT, CImage_NPY_USHORT() },
            { NPY_INT, CImage_NPY_INT() },
            { NPY_UINT, CImage_NPY_UINT() },
            { NPY_LONG, CImage_NPY_LONG() },
            { NPY_ULONG, CImage_NPY_ULONG() },
            { NPY_LONGLONG, CImage_NPY_LONGLONG() },
            { NPY_ULONGLONG, CImage_NPY_ULONGLONG() }
        };
        return _cimage_wrapper_map;
    }
    
    static const map<npy_intp, CImage_Base> cimage_wrappers;
    
};

const map<npy_intp, CImage_Base> typecodemap::cimage_wrappers = typecodemap::init_cimage_wrappers();

#endif /// PyImgC_INTERFACE_H