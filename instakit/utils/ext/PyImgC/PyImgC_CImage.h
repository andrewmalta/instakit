#ifndef PyImgC_CIMAGE_H
#define PyImgC_CIMAGE_H

#define cimg_OS 1                       /// unix-like
#define cimg_verbosity 1                /// log to the console
#define cimg_display 0                  /// don't need this

#define cimg_use_png 1                  /// png
#define cimg_use_jpeg 1                 /// jpeg
#define cimg_use_tiff 1                 /// tiff
#define cimg_use_zlib 1                 /// compressed output
#define cimg_use_magick 1               /// ImageMagick++ I/O
#define cimg_use_fftw3 1                /// libFFTW3
//#define cimg_use_openexr 1              /// OpenEXR
//#define cimg_use_lapack 1               /// LAPACK

#include <map>
#include <type_traits>
#include <Python.h>
#include <structmember.h>

#include <numpy/ndarrayobject.h>
#include <numpy/ndarraytypes.h>
#include "numpypp/numpy.hpp"

#include "cimg/CImg.h"
using namespace cimg_library;
using namespace std;
#ifndef cimg_imagepath
#define cimg_imagepath "cimg/img/"
#endif

template <typename T>
struct CCCImage {
    PyObject_HEAD
    PyArray_Descr *dtype;
    CImg<T> *cimage;
};

template <typename T>
CImg<T> from_pybuffer(Py_buffer *pybuffer, int sW, int sH,
                    int channels, bool is_shared=true) {
    CImg<T> view(pybuffer->buf,
        sW, sH, 1,
        channels, is_shared);
    return view;
}

template <typename T>
CImg<T> from_pybuffer(Py_buffer *pybuffer, bool is_shared=true) {
    CImg<T> view(
        pybuffer->buf,
        pybuffer->shape[1],
        pybuffer->shape[0],
        1, 3, is_shared);
    return view;
}

template <typename T>
CImg<T> from_pyarray(PyArrayObject *pyarray, bool is_shared=true) {
    int sW = 0;
    int sH = 0;
    int channels = 0;
    switch (PyArray_NDIM(pyarray)) {
        case 3:
        {
            channels = PyArray_DIM(pyarray, 2); /// starts from zero, right?...
            sW = PyArray_DIM(pyarray, 1);
            sH = PyArray_DIM(pyarray, 0);
        }
        break;
        case 2:
        {
            channels = 1;
            sW = PyArray_DIM(pyarray, 1);
            sH = PyArray_DIM(pyarray, 0);
        }
        break;
        default:
        {
            return NULL;
        }
        break;
    }
    CImg<T> view(PyArray_DATA(pyarray), sW, sH,
        1, channels, is_shared);
    return view;
}

template <typename T>
CImg<T> from_pyobject(PyObject *datasource, int sW, int sH,
                    int channels, bool is_shared=true) {
    CImg<T> view(sW, sH, 1, channels, is_shared);
    return view;
}

template <typename T>
CImg<T> from_pyobject(PyObject *datasource, bool is_shared=true) {
    CImg<T> view(640, 480, 1, 3, is_shared);
    return view;
}

#define NILCODE '~'

struct CImage_SubBase {};

template <typename dT>
struct CImage_Traits;

template <typename dT>
struct CImage_Base : public CImage_SubBase {
    typedef typename CImage_Traits<dT>::value_type value_type;

    CImg<value_type> as_pybuffer(Py_buffer *pybuffer, bool is_shared=true) {
        return from_pybuffer<bool>(pybuffer, is_shared); }

    CImg<value_type> as_pybuffer_with_dims(Py_buffer *pybuffer,
        int sW, int sH, int channels=3,
        bool is_shared=true) {
        return from_pybuffer<value_type>(pybuffer, sW, sH, channels, is_shared); }

    CImg<value_type> as_pyarray(PyArrayObject *pyarray, bool is_shared=true) {
        return from_pyarray<value_type>(pyarray, is_shared); }

    CImg<value_type> as_datasource(PyObject *datasource, bool is_shared=true) {
        return from_pyobject<value_type>(datasource, is_shared); }

    CImg<value_type> as_datasource_with_dims(Py_buffer *pybuffer,
        int sW, int sH, int channels=3,
        bool is_shared=true) {
        return from_pybuffer<value_type>(pybuffer, sW, sH, channels, is_shared); }

    inline bool operator()(const char sc) {
        dT self = static_cast<dT*>(this);
        for (int idx = 0; self->structcode[idx] != NILCODE; ++idx) {
            if (self->structcode[idx] == sc) { return true; }
        }
        return false; }
    
    inline bool operator[](const npy_intp tc) {
        dT self = static_cast<dT*>(this);
        return tc == self->typecode();
    }
    
    template <typename... Args>
    static dT& get_instance(Args... args) {
        static dT instance{std::forward<Args>(args)...};
        return instance;
    }
    
    //static dT& for_typecode(typecode) {}
};

template <typename T>
struct CImage_Type : public CImage_Base<CImage_Type<T>> {
    typedef typename CImage_Traits<CImage_Type>::value_type value_type;
    npy_intp typecode() {
        return numpy::dtype_code<value_type>();
    }
};

template <typename T>
struct CImage_Traits<CImage_Type<T>> {
    typedef T value_type;
};

/////////////////////////////////// AUTOGENERATED ///////////////////////////////////////
/////////////////////////////////// AUTOGENERATED ///////////////////////////////////////
/////////////////////////////////// AUTOGENERATED ///////////////////////////////////////


struct CImage_NPY_BOOL : public CImage_Type<bool> {
    const char structcode[2] = { '?', NILCODE };
    const unsigned int structcode_length = 2;
    //const npy_intp typecode = NPY_BOOL;
    const bool native = true;
    const bool complex = false;
    CImage_NPY_BOOL() {}
};


struct CImage_NPY_BYTE : public CImage_Type<char> {
    const char structcode[2] = { 'b', NILCODE };
    const unsigned int structcode_length = 2;
    //const npy_intp typecode = NPY_BYTE;
    const bool native = true;
    const bool complex = false;
    CImage_NPY_BYTE() {}
};


struct CImage_NPY_HALF : public CImage_Type<npy_half> {
    const char structcode[2] = { 'e', NILCODE };
    const unsigned int structcode_length = 2;
    //const npy_intp typecode = NPY_HALF;
    const bool native = false;
    const bool complex = false;
    CImage_NPY_HALF() {}
};


struct CImage_NPY_SHORT : public CImage_Type<short> {
    const char structcode[2] = { 'h', NILCODE };
    const unsigned int structcode_length = 2;
    //const npy_intp typecode = NPY_SHORT;
    const bool native = true;
    const bool complex = false;
    CImage_NPY_SHORT() {}
};


struct CImage_NPY_INT : public CImage_Type<int> {
    const char structcode[2] = { 'i', NILCODE };
    const unsigned int structcode_length = 2;
    //const npy_intp typecode = NPY_INT;
    const bool native = true;
    const bool complex = false;
    CImage_NPY_INT() {}
};


struct CImage_NPY_LONG : public CImage_Type<long> {
    const char structcode[2] = { 'l', NILCODE };
    const unsigned int structcode_length = 2;
    //const npy_intp typecode = NPY_LONG;
    const bool native = true;
    const bool complex = false;
    CImage_NPY_LONG() {}
};


struct CImage_NPY_LONGLONG : public CImage_Type<long long> {
    const char structcode[2] = { 'q', NILCODE };
    const unsigned int structcode_length = 2;
    //const npy_intp typecode = NPY_LONGLONG;
    const bool native = true;
    const bool complex = false;
    CImage_NPY_LONGLONG() {}
};


struct CImage_NPY_UBYTE : public CImage_Type<unsigned char> {
    const char structcode[2] = { 'B', NILCODE };
    const unsigned int structcode_length = 2;
    //const npy_intp typecode = NPY_UBYTE;
    const bool native = true;
    const bool complex = false;
    CImage_NPY_UBYTE() {}
};


struct CImage_NPY_USHORT : public CImage_Type<unsigned short> {
    const char structcode[2] = { 'H', NILCODE };
    const unsigned int structcode_length = 2;
    //const npy_intp typecode = NPY_USHORT;
    const bool native = true;
    const bool complex = false;
    CImage_NPY_USHORT() {}
};


struct CImage_NPY_UINT : public CImage_Type<unsigned int> {
    const char structcode[2] = { 'I', NILCODE };
    const unsigned int structcode_length = 2;
    //const npy_intp typecode = NPY_UINT;
    const bool native = true;
    const bool complex = false;
    CImage_NPY_UINT() {}
};


struct CImage_NPY_ULONG : public CImage_Type<unsigned long> {
    const char structcode[2] = { 'L', NILCODE };
    const unsigned int structcode_length = 2;
    //const npy_intp typecode = NPY_ULONG;
    const bool native = true;
    const bool complex = false;
    CImage_NPY_ULONG() {}
};


struct CImage_NPY_ULONGLONG : public CImage_Type<unsigned long long> {
    const char structcode[2] = { 'Q', NILCODE };
    const unsigned int structcode_length = 2;
    //const npy_intp typecode = NPY_ULONGLONG;
    const bool native = true;
    const bool complex = false;
    CImage_NPY_ULONGLONG() {}
};


struct CImage_NPY_INT16 : public CImage_Type<short> {
    const char structcode[2] = { 'h', NILCODE };
    const unsigned int structcode_length = 2;
    //const npy_intp typecode = NPY_INT16;
    const bool native = false;
    const bool complex = false;
    CImage_NPY_INT16() {}
};


struct CImage_NPY_INT32 : public CImage_Type<int> {
    const char structcode[3] = { 'i', 'l', NILCODE };
    const unsigned int structcode_length = 3;
    //const npy_intp typecode = NPY_INT32;
    const bool native = false;
    const bool complex = false;
    CImage_NPY_INT32() {}
};


struct CImage_NPY_INT64 : public CImage_Type<long long> {
    const char structcode[2] = { 'q', NILCODE };
    const unsigned int structcode_length = 2;
    //const npy_intp typecode = NPY_INT64;
    const bool native = false;
    const bool complex = false;
    CImage_NPY_INT64() {}
};


struct CImage_NPY_UINT16 : public CImage_Type<unsigned short> {
    const char structcode[2] = { 'H', NILCODE };
    const unsigned int structcode_length = 2;
    //const npy_intp typecode = NPY_UINT16;
    const bool native = false;
    const bool complex = false;
    CImage_NPY_UINT16() {}
};


struct CImage_NPY_UINT32 : public CImage_Type<unsigned int> {
    const char structcode[3] = { 'I', 'L', NILCODE };
    const unsigned int structcode_length = 3;
    //const npy_intp typecode = NPY_UINT32;
    const bool native = false;
    const bool complex = false;
    CImage_NPY_UINT32() {}
};


struct CImage_NPY_UINT64 : public CImage_Type<unsigned long long> {
    const char structcode[2] = { 'Q', NILCODE };
    const unsigned int structcode_length = 2;
    //const npy_intp typecode = NPY_UINT64;
    const bool native = false;
    const bool complex = false;
    CImage_NPY_UINT64() {}
};


struct CImage_NPY_CFLOAT : public CImage_Type<std::complex<float>> {
    const char structcode[2] = { 'f', NILCODE };
    const unsigned int structcode_length = 2;
    //const npy_intp typecode = NPY_CFLOAT;
    const bool native = false;
    const bool complex = true;
    CImage_NPY_CFLOAT() {}
};


struct CImage_NPY_CDOUBLE : public CImage_Type<std::complex<double>> {
    const char structcode[2] = { 'd', NILCODE };
    const unsigned int structcode_length = 2;
    //const npy_intp typecode = NPY_CDOUBLE;
    const bool native = false;
    const bool complex = true;
    CImage_NPY_CDOUBLE() {}
};


struct CImage_NPY_FLOAT : public CImage_Type<float> {
    const char structcode[2] = { 'f', NILCODE };
    const unsigned int structcode_length = 2;
    //const npy_intp typecode = NPY_FLOAT;
    const bool native = false;
    const bool complex = false;
    CImage_NPY_FLOAT() {}
};


struct CImage_NPY_DOUBLE : public CImage_Type<double> {
    const char structcode[2] = { 'd', NILCODE };
    const unsigned int structcode_length = 2;
    //const npy_intp typecode = NPY_DOUBLE;
    const bool native = false;
    const bool complex = false;
    CImage_NPY_DOUBLE() {}
};


struct CImage_NPY_CLONGDOUBLE : public CImage_Type<std::complex<long double>> {
    const char structcode[2] = { 'g', NILCODE };
    const unsigned int structcode_length = 2;
    //const npy_intp typecode = NPY_CLONGDOUBLE;
    const bool native = true;
    const bool complex = false;
    CImage_NPY_CLONGDOUBLE() {}
};


struct CImage_NPY_LONGDOUBLE : public CImage_Type<std::complex<long double>> {
    const char structcode[2] = { 'g', NILCODE };
    const unsigned int structcode_length = 2;
    //const npy_intp typecode = NPY_LONGDOUBLE;
    const bool native = true;
    const bool complex = true;
    CImage_NPY_LONGDOUBLE() {}
};

/////////////////////////////////// !AUTOGENERATED ///////////////////////////////////////
/////////////////////////////////// !AUTOGENERATED ///////////////////////////////////////
/////////////////////////////////// !AUTOGENERATED ///////////////////////////////////////

auto CImage_ForTypecode(npy_intp typecode) -> decltype(make_pair(NPY_BOOL, CImage_SubBase())) {
    switch (typecode) {
        case NPY_BOOL: return make_pair(NPY_BOOL, CImage_NPY_BOOL());
        case NPY_BYTE: return make_pair(NPY_BYTE, CImage_NPY_BYTE());
        case NPY_UBYTE: return make_pair(NPY_UBYTE, CImage_NPY_UBYTE());

        case NPY_INT16: return make_pair(NPY_INT16, CImage_NPY_INT16());
        case NPY_UINT16: return make_pair(NPY_UINT16, CImage_NPY_UINT16());
        case NPY_INT32: return make_pair(NPY_INT32, CImage_NPY_INT32());
        case NPY_UINT32: return make_pair(NPY_UINT32, CImage_NPY_UINT32());
        //case NPY_INT32: return make_pair(NPY_INT32, CImage_NPY_INT32());
        //case NPY_UINT32: return make_pair(NPY_UINT32, CImage_NPY_UINT32());
        case NPY_INT64: return make_pair(NPY_INT64, CImage_NPY_INT64());
        case NPY_UINT64: return make_pair(NPY_UINT64, CImage_NPY_UINT64());

        case NPY_HALF: return make_pair(NPY_HALF, CImage_NPY_HALF());
        case NPY_FLOAT: return make_pair(NPY_FLOAT, CImage_NPY_FLOAT());
        case NPY_DOUBLE: return make_pair(NPY_DOUBLE, CImage_NPY_DOUBLE());
        case NPY_LONGDOUBLE: return make_pair(NPY_LONGDOUBLE, CImage_NPY_LONGDOUBLE());
        case NPY_CFLOAT: return make_pair(NPY_CFLOAT, CImage_NPY_CFLOAT());
        case NPY_CDOUBLE: return make_pair(NPY_CDOUBLE, CImage_NPY_CDOUBLE());
        case NPY_CLONGDOUBLE: return make_pair(NPY_CLONGDOUBLE, CImage_NPY_CLONGDOUBLE());

        /* dupes!
        case NPY_SHORT: return make_pair(NPY_SHORT, CImage_NPY_SHORT());
        case NPY_USHORT: return make_pair(NPY_USHORT, CImage_NPY_USHORT());
        case NPY_INT: return make_pair(NPY_INT, CImage_NPY_INT());
        case NPY_UINT: return make_pair(NPY_UINT, CImage_NPY_UINT());
        case NPY_LONG: return make_pair(NPY_LONG, CImage_NPY_LONG());
        case NPY_ULONG: return make_pair(NPY_ULONG, CImage_NPY_ULONG());
        case NPY_LONGLONG: return make_pair(NPY_LONGLONG, CImage_NPY_LONGLONG());
        case NPY_ULONGLONG: return make_pair(NPY_ULONGLONG, CImage_NPY_ULONGLONG());
        */
    }
    return make_pair(NPY_INT, CImage_SubBase());
}


#endif /// PyImgC_INTERFACE_H